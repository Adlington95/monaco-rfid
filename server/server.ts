import express, { Request, Response } from "express";
import cors from "cors";
import websocket from "ws";
import {
  lightToggle,
  rfidCheckValidity,
  rfidCompareToPrevious,
  rfidQualifyingLap,
  rfidRaceLap,
  rfidSaveData,
  rfidScannedCar,
  rfidStart,
  rfidStop,
  rfidToggle,
} from "./rfid";
import { pool } from "./db";
import { delay } from "./utils";
import { RfidResponse, Status } from "./models";

const port = 3000;

// Time to debounce the RFID reader in milliseconds
export const debounceTime = 2500;

const app = express();
app.use(express.json());
app.use(cors());

// TODO: Test logic for the lights to go on
// TODO: Can we even do head to head?

// Naughty line needed as I can't be bothered with SSL
process.env["NODE_TLS_REJECT_UNAUTHORIZED"] = "0";

/// This token will be generated by the RFID reader for auth
export let token: string | undefined | null;

// name of the scanned in user
let scannedName: string | undefined;

// id of the scanned in user
export let qualifyingUserId: string | undefined;

// Whether the RFID reader is toggling
export let toggling: boolean = false;

//scanned car id
let qualifyingCarId: string | undefined;

let raceCarIds: string[] = [];
let raceUserIds: string[] = [];

//lap times of the scanned car
let lapTimes: Map<string, number[]> = new Map();
let rfidTimes: Map<string, string[]> = new Map();

let lastData: Map<string, string> = new Map();

let status = Status.READY;

// Create  WebSocket server
export const wss = new websocket.Server({ port: 8080 }).on("connection", (ws) => {
  console.log("Client connected");

  // Handle client disconnection
  ws.on("close", () => console.log("Client disconnected"));
});

// GET all entries
app.get("/", async (req, res: Response) => {
  try {
    const data = await pool.query("SELECT * FROM monaco");
    res.status(200).send(data.rows);
  } catch (err) {
    console.log(err);
    res.sendStatus(500);
  }
});

// Clear db table
app.get("/removeAllEntries", async (req, res: Response) => {
  try {
    await pool.query("DELETE FROM monaco");

    res.status(200).send({ message: "Successfully deleted all entries, but maintained the table structure" });
  } catch (err) {
    console.log(err);
    res.sendStatus(500);
  }
});

// Remove table from db
app.get("/removeTableFromDb", async (req, res: Response) => {
  try {
    await pool.query("DROP TABLE monaco");

    res.status(200).send({ message: "Successfully deleted monaco from db" });
  } catch (err) {
    console.log(err);
    res.sendStatus(500);
  }
});

// CREATE TABLE
app.get("/setup", async (_, res: Response) => {
  try {
    await pool.query(
      "CREATE TABLE monaco( id SERIAL, name VARCHAR(100), lap_time VARCHAR(100), team_name VARCHAR(100), attempts INT DEFAULT 0, employee_id VARCHAR(100) PRIMARY KEY )"
    );

    res.status(200).send({ message: "Successfully created table" });
  } catch (err) {
    console.log(err);
    res.sendStatus(500);
  }
});

// Start RFID Reader
app.get("/start", async (_, res: Response) => {
  try {
    await rfidStart();
    res.status(200);
  } catch (e) {
    console.error(e);
    res.sendStatus(500);
  }
});

// Stop RFID Reader
app.get("/stop", async (_, res: Response) => {
  try {
    rfidStop();
    res.status(200);
  } catch (e) {
    console.error(e);
    res.sendStatus(500);
  }
});

// Get status of the server
app.get("/status", async (_, res: Response) => {
  res.status(200).send({ status: status });
});

// Get the current users data
app.get("/getUser", async (_, res: Response) => {
  console.log("sending user data to the frontend");

  res.send({ scannedId: qualifyingUserId, scannedName });
});

// Get the leaderboard
app.get("/getLeaderboard", async (_, res: Response) => {
  try {
    const data = await pool.query("SELECT * FROM monaco ORDER BY lap_time ASC LIMIT 10");
    res.status(200).send(data.rows);
  } catch (err) {
    console.log(err);
    res.sendStatus(500);
  }
});

// Post RFID data
app.post("/rfid", async (req, _) => {
  console.log("RFID data received.");
  // Check if this is an RFID data response
  if (rfidCheckValidity(req.body, qualifyingUserId, raceUserIds) && !toggling) {
    console.log("Valid");

    // Parse the JSON data, only return new data
    const json = rfidCompareToPrevious(lastData, req.body);
    if (json) {
      rfidToggle();
      if (status !== Status.RACE) {
        // Qualifying
        if (!qualifyingCarId) {
          qualifyingCarId = rfidScannedCar(json);
          rfidTimes.set(json.data.idHex, [json.timestamp]);
        } else if (qualifyingCarId == json.data.idHex) {
          const userRfidTimes = rfidTimes.get(json.data.idHex);
          const lastRFIDTime = userRfidTimes ? userRfidTimes[userRfidTimes.length - 1] : undefined;
          if (lastRFIDTime) {
            console.log("Last RFID time: " + lastRFIDTime);
            lapTimes.set(
              json.data.idHex,
              rfidQualifyingLap(json.timestamp, lastRFIDTime, lapTimes.get(json.data.idHex) ?? [])
            );
            wss.clients.forEach((client) => {
              if (client.readyState === websocket.OPEN) {
                client.send(JSON.stringify(Object.fromEntries(lapTimes)));
              }
            });
          } else {
            console.log("No previous RFID time");
            rfidTimes.set(json.data.idHex, [json.timestamp]);
          }
        }
      } else {
        // Race
        if (raceCarIds.length > 2) {
          raceCarIds.push(json.data.idHex);
        } else if (raceCarIds.includes(json.data.idHex)) {
          // rfidRaceLap(json.timestamp, rfidTimes[rfidTimes.length - 1], lapTimes);
        }
      }
      addToRFIDTimes(json);
    }
  } else {
    console.log("Data not valid");
  }
  lastData = rfidSaveData(req.body, lastData);
});

const addToRFIDTimes = (json: RfidResponse) => {
  const userRfidTimes = rfidTimes.get(json.data.idHex) ?? [];
  userRfidTimes.push(json.timestamp);
  rfidTimes.set(json.data.idHex, userRfidTimes);
};

// Post new lap
app.post("/lap", async (req: Request, res: Response) => {
  const { lap_time } = req.body;
  console.log("Finding the current player in the database..");

  //if scannedId exists in the database then we should UPDATE otherwise INSERT
  try {
    await pool.query(
      `INSERT INTO monaco (name, lap_time, team_name, attempts, employee_id)
                VALUES ($1, $2, $3, $4, $5)
                ON CONFLICT (employee_id)
                DO UPDATE
                SET
                    team_name=EXCLUDED.team_name,
                    lap_time=EXCLUDED.lap_time,
                    attempts = monaco.attempts+1`,
      [scannedName, lap_time, qualifyingCarId, 0, qualifyingUserId]
    );

    res.status(200).send({ message: "Successfully inserted entry into monaco" });
    resetQualifying();
  } catch (err) {
    console.log(err);
    res.sendStatus(500);
  }
});

// Post in new user data
app.post("/scanUser", async (req: Request, res: Response) => {
  try {
    const response = req.body;
    const { name, id } = response;
    qualifyingUserId = id;
    scannedName = name;

    console.log("Set scanned id to " + qualifyingUserId);
    console.log("Set scanned name to " + scannedName);

    const data = await pool.query("SELECT * FROM monaco WHERE employee_id = $1 LIMIT 1", [qualifyingUserId]);

    //returns nothing if the user does not exist in the database
    //return [UserData] if the user does exist in the database
    res.status(200).send(data.rows[0]);
  } catch (e) {
    console.error(e);
    res.sendStatus(500);
  }
  rfidToggle();
});

// Post for lights to start
app.post("/lights", async (_, res: Response) => {
  try {
    // All lights off
    lightToggle(1, false);
    lightToggle(2, false);
    lightToggle(3, false);
    lightToggle(4, false);

    // Small wait
    await delay(3000);

    // Lights on in sequence
    lightToggle(1, true);
    await delay(1000);
    lightToggle(2, true);
    await delay(1000);
    lightToggle(3, true);
    await delay(1000);
    lightToggle(4, true);

    // Random delay
    await delay(Math.floor(Math.random() * 5000) + 800);

    // All lights off
    lightToggle(1, false);
    lightToggle(2, false);
    lightToggle(3, false);
    lightToggle(4, false);
    res.sendStatus(200);
  } catch (e) {
    console.error(e);
    res.sendStatus(500);
  }
});

// Post new status
app.post("/status", async (req: Request, res: Response) => {
  let newStatus = req.body.status;
  if (status === Status.READY) {
    resetQualifying();
  }
  status = newStatus;
  console.log("Status updated to " + newStatus);

  res.status(200).send({ message: "Status updated" });
});

// Start Rest Server
app.listen(port, () => console.log(`Server has started on port: ${port}`));

// Reset qualifying data
const resetQualifying = () => {
  console.log("resetting qualifying local data");
  qualifyingUserId = undefined;
  scannedName = undefined;
  qualifyingCarId = undefined;
  lapTimes = new Map();
};

// Set whether the RFID reader is toggling
export const setToggling = (value: boolean) => (toggling = value);

// Set the token
export const setToken = (value: string | null) => (token = value);

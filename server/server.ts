import nodefetch from "node-fetch";
import express from "express";
import cors from "cors";
import websocket from "ws";
import { rfidGetToken, rfidStart, rfidStop } from "./rfid";
import { pool } from "./db";
import { delay } from "./utils";
import { Status } from "./models";

const port = 3000;
const rfidAddress = process.env.RFID_ADDRESS;

export const debounceTime = 2500; // In milliseconds

const app = express();
app.use(express.json());
app.use(cors());

// TODO: Test logic for the lights to go on
// TODO: Can we even do head to head?

// Naughty line needed as I can't be bothered with SSL
process.env["NODE_TLS_REJECT_UNAUTHORIZED"] = "0";

/// This token will be generated by the RFID reader for auth
let token: string | undefined;

//name of the scanned in user
let scannedName: string | undefined;

//id of the scanned in user
let scannedId: string | undefined;

//scanned car id
let scannedCarId: string | undefined;

//lap times of the scanned car
let lapTimes: number[] = [];

let rfidTimes: number[] = [];

let lastData = {};

let toggling = false;

// create variable named wss
export const wss = new websocket.Server({ port: 8080 });

// Handle WebSocket connections
wss.on("connection", (ws) => {
  console.log("Client connected");

  // Handle client disconnection
  ws.on("close", () => {
    // rfidOn = false;
    console.log("Client disconnected");
  });
});

// GET all entries
app.get("/", async (req, res) => {
  try {
    const data = await pool.query("SELECT * FROM monaco");
    res.status(200).send(data.rows);
  } catch (err) {
    console.log(err);
    res.sendStatus(500);
  }
});

app.post("/rfid", async (req, _) => {
  console.log("RFID data received");
  // Check if this is an RFID data response
  if (rfidCheckValidity(req.body) && !toggling) {
    console.log("Valid");
    // Save the previous data to compare against for lap time

    // Parse the JSON data, only return new data
    const json = rfidCompareToPrevious(lastData, req.body);
    if (json) {
      rfidToggle();

      if (!scannedCarId) {
        rfidScannedCar(json);
      } else if (scannedCarId == json.data.idHex) {
        console.log(rfidTimes);
        rfidLap(json.timestamp, rfidTimes[rfidTimes.length - 1]);
      }
      rfidTimes.push(json.timestamp);
    }
  } else {
    console.log("Data not valid");
  }
  rfidSaveData(req.body);
});

// Post new lap
app.post("/lap", async (req, res) => {
  const { lap_time } = req.body;
  console.log("Finding the current player in the database..");

  //if scannedId exists in the database then we should UPDATE otherwise INSERT
  try {
    await pool.query(
      `INSERT INTO monaco (name, lap_time, team_name, attempts, employee_id)
                VALUES ($1, $2, $3, $4, $5)
                ON CONFLICT (employee_id)
                DO UPDATE
                SET
                    team_name=EXCLUDED.team_name,
                    lap_time=EXCLUDED.lap_time,
                    attempts = monaco.attempts+1`,
      [scannedName, lap_time, scannedCarId, 0, scannedId]
    );

    res.status(200).send({ message: "Successfully inserted entry into monaco" });
    resetQualifying();
  } catch (err) {
    console.log(err);
    res.sendStatus(500);
  }
});

// Clear db table
app.get("/removeAllEntries", async (req, res) => {
  try {
    await pool.query("DELETE FROM monaco");

    res.status(200).send({ message: "Successfully deleted all entries, but maintained the table structure" });
  } catch (err) {
    console.log(err);
    res.sendStatus(500);
  }
});

// Remove table from db
app.get("/removeTableFromDb", async (req, res) => {
  try {
    await pool.query("DROP TABLE monaco");

    res.status(200).send({ message: "Successfully deleted monaco from db" });
  } catch (err) {
    console.log(err);
    res.sendStatus(500);
  }
});

// CREATE TABLE
app.get("/setup", async (req, res) => {
  try {
    await pool.query(
      "CREATE TABLE monaco( id SERIAL, name VARCHAR(100), lap_time VARCHAR(100), team_name VARCHAR(100), attempts INT DEFAULT 0, employee_id VARCHAR(100) PRIMARY KEY )"
    );

    res.status(200).send({ message: "Successfully created table" });
  } catch (err) {
    console.log(err);
    res.sendStatus(500);
  }
});

// Start RFID Reader
app.get("/start", async (req, res) => {
  try {
    await rfidStart(token);
    res.status(200);
  } catch (e) {
    console.error(e);
    res.sendStatus(500);
  }
});

// Stop RFID Reader
app.get("/stop", async (req, res) => {
  try {
    rfidStop(token);
    res.status(200);
  } catch (e) {
    console.error(e);
    res.sendStatus(500);
  }
});

app.post("/scanUser", async (req, res) => {
  try {
    const response = req.body;
    const { name, id } = response;
    scannedId = id;
    scannedName = name;

    console.log("Set scanned id to " + scannedId);
    console.log("Set scanned name to " + scannedName);

    const data = await pool.query("SELECT * FROM monaco WHERE employee_id = $1 LIMIT 1", [scannedId]);

    //returns nothing if the user does not exist in the database
    //return [UserData] if the user does exist in the database
    res.status(200).send(data.rows[0]);
  } catch (e) {
    console.error(e);
    res.sendStatus(500);
  }
  rfidToggle();
});

app.post("/lights", async (req, res) => {
  try {
    // All lights off
    lightToggle(1, false);
    lightToggle(2, false);
    lightToggle(3, false);
    lightToggle(4, false);

    // Small wait
    await delay(3000);

    // Lights on in sequence
    lightToggle(1, true);
    await delay(1000);
    lightToggle(2, true);
    await delay(1000);
    lightToggle(3, true);
    await delay(1000);
    lightToggle(4, true);

    // Random delay
    await delay(Math.floor(Math.random() * 5000) + 800);

    // All lights off
    lightToggle(1, false);
    lightToggle(2, false);
    lightToggle(3, false);
    lightToggle(4, false);
    res.sendStatus(200);
  } catch (e) {
    console.error(e);
    res.sendStatus(500);
  }
});

app.get("/status", async (req, res) => {
  let status = Status.UNKNOWN;

  if (!scannedId) {
    status = Status.READY;
  } else if (scannedId && !scannedCarId) {
    status = Status.USER_SCANNED;
  } else if (scannedId && scannedCarId && lapTimes.length === 0) {
    status = Status.CAR_SCANNED;
  } else if (scannedId && scannedCarId && lapTimes.length > 0 && lapTimes.length <= 4) {
    status = Status.PRACTICE;
  } else if (scannedId && scannedCarId && lapTimes.length > 4) {
    status = Status.QUALIFYING;
  }
  //TODO: Add check for qualifying complete

  res.status(200).send({ status: status });
});

app.post("/status", async (req, res) => {
  let status = req.body.status;
  console.log(req.body);

  switch (status) {
    case Status.READY:
      resetQualifying();
      break;
    case Status.USER_SCANNED:
      scannedCarId = undefined;
      const lastTime = rfidTimes.pop();
      rfidTimes = [];
      if (lastTime) rfidTimes.push(lastTime);
      break;
    case Status.CAR_SCANNED:
      lapTimes = [];
      break;
    case Status.PRACTICE:
      while (lapTimes.length > 3) lapTimes.shift();
      break;
    case Status.QUALIFYING:
      while (lapTimes.length > 4) lapTimes.shift();
      break;
    case Status.QUALIFYING_COMPLETE:
      // Handle qualifying complete status
      break;
    default:
      console.log("Unknown status");
  }

  console.log("Status updated to " + status);

  res.status(200).send({ message: "Status updated" });
});

async function lightToggle(num, on) {
  if (token == null) {
    await rfidGetToken();
  }
  nodefetch(`https://${rfidAddress}/cloud/gpo`, {
    method: "POST",
    headers: {
      Authorization: `Bearer ${token}`,
    },
    body: JSON.stringify({
      port: num,
      state: !on,
    }),
  });
}

function resetQualifying() {
  console.log("resetting qualifying local data");
  scannedId = undefined;
  scannedName = undefined;
  scannedCarId = undefined;
  lapTimes = [];
}

app.get("/getUser", async (req, res) => {
  console.log("sending user data to the frontend");

  res.send({
    scannedId,
    scannedName,
  });
});

app.get("/getLeaderboard", async (req, res) => {
  try {
    const data = await pool.query("SELECT * FROM monaco ORDER BY lap_time ASC LIMIT 10");
    res.status(200).send(data.rows);
  } catch (err) {
    console.log(err);
    res.sendStatus(500);
  }
});

app.get("/getTeamLeaderboard", async (req, res) => {
  try {
    const data = await pool.query("SELECT * FROM monaco ORDER BY lap_time ASC");
    //create array from data.rows of the top 10 employee_id based on their lap_time value in ascending order. The same employee_id cannot appear twice
    const idsList: string[] = [];
    const dataList: any[] = [];

    data.rows.forEach((rowItem) => {
      if (!idsList.includes(rowItem.team_name)) {
        idsList.push(rowItem.team_name);
        dataList.push({
          team_name: rowItem.team_name,
          lap_time: rowItem.lap_time,
        });
      }
    });

    res.status(200).send(dataList);
  } catch (err) {
    console.log(err);
    res.sendStatus(500);
  }
});

app.listen(port, () => console.log(`Server has started on port: ${port}`));
